set
Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.bWc16DsLFB/Render
BASH=/bin/bash
BASH_ARGC=()
BASH_ARGV=()
BASH_LINENO=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="3" [1]="2" [2]="57" [3]="1" [4]="release" [5]="x86_64-apple-darwin15")
BASH_VERSION='3.2.57(1)-release'
CLICOLOR=1
COLUMNS=101
COMMAND_MODE=unix2003
DIRSTACK=()
EDITOR=vim
EUID=501
EVENT_NOKQUEUE=1
GROUPS=()
HISTFILE=/Users/alexhurst/.bash_history
HISTFILESIZE=500
HISTSIZE=500
HOME=/Users/alexhurst
HOSTNAME=alex.local
HOSTTYPE=x86_64
IFS=$' \t\n'
ITERM_PROFILE=Default
ITERM_SESSION_ID=w1t0p0
LANG=en_US.UTF-8
LINES=63
LOGNAME=alexhurst
LS_COLORS='rs=0:di=38;5;27:ln=38;5;51:mh=44;38;5;15:pi=40;38;5;11:so=38;5;13:do=38;5;5:bd=48;5;232;38;5;11:cd=48;5;232;38;5;3:or=48;5;232;38;5;9:mi=05;48;5;232;38;5;15:su=48;5;196;38;5;15:sg=48;5;11;38;5;16:ca=48;5;196;38;5;226:tw=48;5;10;38;5;16:ow=48;5;10;38;5;21:st=48;5;21;38;5;15:ex=38;5;34:*.tar=38;5;9:*.tgz=38;5;9:*.arc=38;5;9:*.arj=38;5;9:*.taz=38;5;9:*.lha=38;5;9:*.lz4=38;5;9:*.lzh=38;5;9:*.lzma=38;5;9:*.tlz=38;5;9:*.txz=38;5;9:*.tzo=38;5;9:*.t7z=38;5;9:*.zip=38;5;9:*.z=38;5;9:*.Z=38;5;9:*.dz=38;5;9:*.gz=38;5;9:*.lrz=38;5;9:*.lz=38;5;9:*.lzo=38;5;9:*.xz=38;5;9:*.bz2=38;5;9:*.bz=38;5;9:*.tbz=38;5;9:*.tbz2=38;5;9:*.tz=38;5;9:*.deb=38;5;9:*.rpm=38;5;9:*.jar=38;5;9:*.war=38;5;9:*.ear=38;5;9:*.sar=38;5;9:*.rar=38;5;9:*.alz=38;5;9:*.ace=38;5;9:*.zoo=38;5;9:*.cpio=38;5;9:*.7z=38;5;9:*.rz=38;5;9:*.cab=38;5;9:*.jpg=38;5;13:*.jpeg=38;5;13:*.gif=38;5;13:*.bmp=38;5;13:*.pbm=38;5;13:*.pgm=38;5;13:*.ppm=38;5;13:*.tga=38;5;13:*.xbm=38;5;13:*.xpm=38;5;13:*.tif=38;5;13:*.tiff=38;5;13:*.png=38;5;13:*.svg=38;5;13:*.svgz=38;5;13:*.mng=38;5;13:*.pcx=38;5;13:*.mov=38;5;13:*.mpg=38;5;13:*.mpeg=38;5;13:*.m2v=38;5;13:*.mkv=38;5;13:*.webm=38;5;13:*.ogm=38;5;13:*.mp4=38;5;13:*.m4v=38;5;13:*.mp4v=38;5;13:*.vob=38;5;13:*.qt=38;5;13:*.nuv=38;5;13:*.wmv=38;5;13:*.asf=38;5;13:*.rm=38;5;13:*.rmvb=38;5;13:*.flc=38;5;13:*.avi=38;5;13:*.fli=38;5;13:*.flv=38;5;13:*.gl=38;5;13:*.dl=38;5;13:*.xcf=38;5;13:*.xwd=38;5;13:*.yuv=38;5;13:*.cgm=38;5;13:*.emf=38;5;13:*.axv=38;5;13:*.anx=38;5;13:*.ogv=38;5;13:*.ogx=38;5;13:*.aac=38;5;45:*.au=38;5;45:*.flac=38;5;45:*.mid=38;5;45:*.midi=38;5;45:*.mka=38;5;45:*.mp3=38;5;45:*.mpc=38;5;45:*.ogg=38;5;45:*.ra=38;5;45:*.wav=38;5;45:*.axa=38;5;45:*.oga=38;5;45:*.spx=38;5;45:*.xspf=38;5;45:'
MACHTYPE=x86_64-apple-darwin15
MAILCHECK=60
MANPATH=/usr/local/opt/coreutils/libexec/gnuman:/usr/share/man:/usr/local/share/man:/usr/local/opt/coreutils/libexec/gnuman
OLDPWD=/Users/alexhurst/tmp
OPTERR=1
OPTIND=1
OSTYPE=darwin15
PATH=/Library/Frameworks/Python.framework/Versions/3.5/bin:/usr/local/sbin:/usr/local/opt/coreutils/libexec/gnubin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Frameworks/Python.framework/Versions/3.5/bin:/usr/local/sbin:/usr/local/opt/coreutils/libexec/gnubin:/Users/alexhurst/scripts:/Users/alexhurst/python/bin:/Library/PostgreSQL/9.3/bin:/usr/local/Cellar/mtr/0.86/sbin:/Users/alexhurst/Hurst/scripts/tick:/Users/alexhurst/scripts:/Users/alexhurst/python/bin:/Library/PostgreSQL/9.3/bin:/usr/local/Cellar/mtr/0.86/sbin:/Users/alexhurst/Hurst/scripts/tick
PIPESTATUS=([0]="0")
PPID=3570
PS1='\u@\[\e[0;94m\]\h\[\e[0;37m\]:\[\e[0m\]\W\[\e[0;36m\]$\[\e[0m\] '
PS2='> '
PS4='+ '
PWD=/Users/alexhurst/tmp/files
RC=0
SECURITYSESSIONID=186a7
SHELL=/bin/bash
SHELLOPTS=braceexpand:hashall:histexpand:history:interactive-comments:monitor:verbose:vi
SHLVL=2
SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.5thMjpxAe8/Listeners
TERM=screen
TERM_PROGRAM=iTerm.app
TMPDIR=/var/folders/hb/h96d_lsd2ys3p9fn2m8pcgpw0000gn/T/
TMUX=/private/var/folders/hb/h96d_lsd2ys3p9fn2m8pcgpw0000gn/T/tmux-501/default,3570,0
TMUX_PANE=%16
UID=501
USER=alexhurst
VIRTUALENVWRAPPER_ENV_BIN_DIR=bin
VIRTUALENVWRAPPER_HOOK_DIR=/Users/alexhurst/Envs
VIRTUALENVWRAPPER_PROJECT_FILENAME=.project
VIRTUALENVWRAPPER_PYTHON=/usr/bin/python
VIRTUALENVWRAPPER_SCRIPT=/usr/local/bin/virtualenvwrapper.sh
VIRTUALENVWRAPPER_VIRTUALENV=virtualenv
VIRTUALENVWRAPPER_VIRTUALENV_CLONE=virtualenv-clone
VIRTUALENVWRAPPER_WORKON_CD=1
VISUAL=vim
WORKON_HOME=/Users/alexhurst/Envs
XPC_FLAGS=0x0
XPC_SERVICE_NAME=0
_=-v
__CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
_cdsitepackages_complete ()
{
    local cur="$2";
    COMPREPLY=($(cdsitepackages && compgen -d -- "${cur}" ))
}
_cdvirtualenv_complete ()
{
    local cur="$2";
    COMPREPLY=($(cdvirtualenv && compgen -d -- "${cur}" ))
}
_lsvirtualenv_usage ()
{
    echo "lsvirtualenv [-blh]";
    echo "  -b -- brief mode";
    echo "  -l -- long mode";
    echo "  -h -- this help message"
}
_virtualenvs ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    COMPREPLY=($(compgen -W "`virtualenvwrapper_show_workon_options`" -- ${cur}))
}
add2virtualenv ()
{
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    site_packages="`virtualenvwrapper_get_site_packages_dir`";
    if [ ! -d "${site_packages}" ]; then
        echo "ERROR: currently-active virtualenv does not appear to have a site-packages directory" 1>&2;
        return 1;
    fi;
    path_file="$site_packages/_virtualenv_path_extensions.pth";
    if [ "$*" = "" ]; then
        echo "Usage: add2virtualenv dir [dir ...]";
        if [ -f "$path_file" ]; then
            echo;
            echo "Existing paths:";
            cat "$path_file" | grep -v "^import";
        fi;
        return 1;
    fi;
    remove=0;
    if [ "$1" = "-d" ]; then
        remove=1;
        shift;
    fi;
    if [ ! -f "$path_file" ]; then
        echo "import sys; sys.__plen = len(sys.path)" > "$path_file" || return 1;
        echo "import sys; new=sys.path[sys.__plen:]; del sys.path[sys.__plen:]; p=getattr(sys,'__egginsert',0); sys.path[p:p]=new; sys.__egginsert = p+len(new)" >> "$path_file" || return 1;
    fi;
    for pydir in "$@";
    do
        absolute_path="$(virtualenvwrapper_absolutepath "$pydir")";
        if [ "$absolute_path" != "$pydir" ]; then
            echo "Warning: Converting \"$pydir\" to \"$absolute_path\"" 1>&2;
        fi;
        if [ $remove -eq 1 ]; then
            sed -i.tmp "\:^$absolute_path$: d" "$path_file";
        else
            sed -i.tmp '1 a\
'"$absolute_path"'
' "$path_file";
        fi;
        rm -f "${path_file}.tmp";
    done;
    return 0
}
allvirtualenv ()
{
    virtualenvwrapper_verify_workon_home || return 1;
    typeset d;
    IFS='%';
    virtualenvwrapper_show_workon_options | while read d; do
        [ ! -d "$WORKON_HOME/$d" ] && continue;
        echo "$d";
        echo "$d" | sed 's/./=/g';
        ( source "$WORKON_HOME/$d/$VIRTUALENVWRAPPER_ENV_BIN_DIR/activate";
        virtualenvwrapper_cd "$VIRTUAL_ENV";
        "$@" );
        echo;
    done;
    unset IFS
}
cdproject ()
{
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    if [ -f "$VIRTUAL_ENV/$VIRTUALENVWRAPPER_PROJECT_FILENAME" ]; then
        typeset project_dir="$(cat "$VIRTUAL_ENV/$VIRTUALENVWRAPPER_PROJECT_FILENAME")";
        if [ ! -z "$project_dir" ]; then
            virtualenvwrapper_cd "$project_dir";
        else
            echo "Project directory $project_dir does not exist" 1>&2;
            return 1;
        fi;
    else
        echo "No project set in $VIRTUAL_ENV/$VIRTUALENVWRAPPER_PROJECT_FILENAME" 1>&2;
        return 1;
    fi;
    return 0
}
cdsitepackages ()
{
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    typeset site_packages="`virtualenvwrapper_get_site_packages_dir`";
    virtualenvwrapper_cd "$site_packages/$1"
}
cdvirtualenv ()
{
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    virtualenvwrapper_cd "$VIRTUAL_ENV/$1"
}
cpvirtualenv ()
{
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_virtualenv_clone || return 1;
    typeset src_name="$1";
    typeset trg_name="$2";
    typeset src;
    typeset trg;
    if [ "$src_name" = "" ]; then
        echo "Please provide a valid virtualenv to copy.";
        return 1;
    else
        if [ ! -e "$WORKON_HOME/$src_name" ]; then
            src="$(virtualenvwrapper_expandpath "$src_name")";
            if [ ! -e "$src" ]; then
                echo "Please provide a valid virtualenv to copy.";
                return 1;
            fi;
            src_name="$(basename "$src")";
        else
            src="$WORKON_HOME/$src_name";
        fi;
    fi;
    if [ "$trg_name" = "" ]; then
        trg="$WORKON_HOME/$src_name";
        trg_name="$src_name";
    else
        trg="$WORKON_HOME/$trg_name";
    fi;
    trg="$(virtualenvwrapper_expandpath "$trg")";
    if [ -e "$trg" ]; then
        echo "$trg_name virtualenv already exists.";
        return 1;
    fi;
    echo "Copying $src_name as $trg_name...";
    ( [ -n "$ZSH_VERSION" ] && setopt SH_WORD_SPLIT;
    virtualenvwrapper_cd "$WORKON_HOME" && "$VIRTUALENVWRAPPER_VIRTUALENV_CLONE" "$src" "$trg";
    [ -d "$trg" ] && virtualenvwrapper_run_hook "pre_cpvirtualenv" "$src" "$trg_name" && virtualenvwrapper_run_hook "pre_mkvirtualenv" "$trg_name" );
    typeset RC=$?;
    [ $RC -ne 0 ] && return $RC;
    [ ! -d "$WORKON_HOME/$trg_name" ] && return 1;
    workon "$trg_name";
    virtualenvwrapper_run_hook "post_mkvirtualenv";
    virtualenvwrapper_run_hook "post_cpvirtualenv"
}
lssitepackages ()
{
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    typeset site_packages="`virtualenvwrapper_get_site_packages_dir`";
    ls $@ "$site_packages";
    path_file="$site_packages/_virtualenv_path_extensions.pth";
    if [ -f "$path_file" ]; then
        echo;
        echo "_virtualenv_path_extensions.pth:";
        cat "$path_file";
    fi
}
lsvirtualenv ()
{
    typeset long_mode=true;
    if command -v "getopts" >&/dev/null; then
        OPTIND=1;
        while getopts ":blh" opt "$@"; do
            case "$opt" in
                l)
                    long_mode=true
                ;;
                b)
                    long_mode=false
                ;;
                h)
                    _lsvirtualenv_usage;
                    return 1
                ;;
                ?)
                    echo "Invalid option: -$OPTARG" 1>&2;
                    _lsvirtualenv_usage;
                    return 1
                ;;
            esac;
        done;
    else
        typeset -a args;
        args=($(getopt blh "$@"));
        if [ $? != 0 ]; then
            _lsvirtualenv_usage;
            return 1;
        fi;
        for opt in $args;
        do
            case "$opt" in
                -l)
                    long_mode=true
                ;;
                -b)
                    long_mode=false
                ;;
                -h)
                    _lsvirtualenv_usage;
                    return 1
                ;;
            esac;
        done;
    fi;
    if $long_mode; then
        allvirtualenv showvirtualenv "$env_name";
    else
        virtualenvwrapper_show_workon_options;
    fi
}
mkproject ()
{
    typeset -a in_args;
    typeset -a out_args;
    typeset -i i;
    typeset tst;
    typeset a;
    typeset t;
    typeset force;
    typeset templates;
    in_args=("$@");
    force=0;
    if [ -n "$ZSH_VERSION" ]; then
        i=1;
        tst="-le";
    else
        i=0;
        tst="-lt";
    fi;
    while [ $i $tst $# ]; do
        a="${in_args[$i]}";
        case "$a" in
            -h | --help)
                virtualenvwrapper_mkproject_help;
                return
            ;;
            -f | --force)
                force=1
            ;;
            -t)
                i=$(( $i + 1 ));
                templates="$templates ${in_args[$i]}"
            ;;
            *)
                if [ ${#out_args} -gt 0 ]; then
                    out_args=("${out_args[@]-}" "$a");
                else
                    out_args=("$a");
                fi
            ;;
        esac;
        i=$(( $i + 1 ));
    done;
    set -- "${out_args[@]}";
    eval "typeset envname=\$$#";
    virtualenvwrapper_verify_project_home || return 1;
    if [ -d "$PROJECT_HOME/$envname" -a $force -eq 0 ]; then
        echo "Project $envname already exists." 1>&2;
        return 1;
    fi;
    mkvirtualenv "$@" || return 1;
    virtualenvwrapper_cd "$PROJECT_HOME";
    virtualenvwrapper_run_hook "project.pre_mkproject" $envname;
    echo "Creating $PROJECT_HOME/$envname";
    mkdir -p "$PROJECT_HOME/$envname";
    setvirtualenvproject "$VIRTUAL_ENV" "$PROJECT_HOME/$envname";
    virtualenvwrapper_cd "$PROJECT_HOME/$envname";
    for t in $templates;
    do
        echo;
        echo "Applying template $t";
        virtualenvwrapper_run_hook --name $(echo $t | sed 's/^ //') "project.template" "$envname" "$PROJECT_HOME/$envname";
    done;
    virtualenvwrapper_run_hook "project.post_mkproject"
}
mktmpenv ()
{
    typeset tmpenvname;
    typeset RC;
    typeset -a in_args;
    typeset -a out_args;
    in_args=("$@");
    if [ -n "$ZSH_VERSION" ]; then
        i=1;
        tst="-le";
    else
        i=0;
        tst="-lt";
    fi;
    typeset cd_after_activate=$VIRTUALENVWRAPPER_WORKON_CD;
    while [ $i $tst $# ]; do
        a="${in_args[$i]}";
        case "$a" in
            -n | --no-cd)
                cd_after_activate=0
            ;;
            -c | --cd)
                cd_after_activate=1
            ;;
            *)
                if [ ${#out_args} -gt 0 ]; then
                    out_args=("${out_args[@]-}" "$a");
                else
                    out_args=("$a");
                fi
            ;;
        esac;
        i=$(( $i + 1 ));
    done;
    set -- "${out_args[@]}";
    tmpenvname=$("$VIRTUALENVWRAPPER_PYTHON" -c 'import uuid,sys; sys.stdout.write(uuid.uuid4()+"\n")' 2>/dev/null);
    if [ -z "$tmpenvname" ]; then
        tmpenvname=$("$VIRTUALENVWRAPPER_PYTHON" -c 'import random,sys; sys.stdout.write(hex(random.getrandbits(64))[2:-1]+"\n")' 2>/dev/null);
    fi;
    tmpenvname="tmp-$tmpenvname";
    mkvirtualenv "$@" "$tmpenvname";
    RC=$?;
    if [ $RC -ne 0 ]; then
        return $RC;
    fi;
    [ "$cd_after_activate" = "1" ] && cdvirtualenv;
    echo "This is a temporary environment. It will be deleted when you run 'deactivate'." | tee "$VIRTUAL_ENV/README.tmpenv";
    cat - >> "$VIRTUAL_ENV/$VIRTUALENVWRAPPER_ENV_BIN_DIR/postdeactivate"  <<EOF
if [ -f "$VIRTUAL_ENV/README.tmpenv" ]
then
    echo "Removing temporary environment:" $(basename "$VIRTUAL_ENV")
    rmvirtualenv $(basename "$VIRTUAL_ENV")
fi
EOF

}
mkvirtualenv ()
{
    typeset -a in_args;
    typeset -a out_args;
    typeset -i i;
    typeset tst;
    typeset a;
    typeset envname;
    typeset requirements;
    typeset packages;
    typeset interpreter;
    typeset project;
    in_args=("$@");
    if [ -n "$ZSH_VERSION" ]; then
        i=1;
        tst="-le";
    else
        i=0;
        tst="-lt";
    fi;
    while [ $i $tst $# ]; do
        a="${in_args[$i]}";
        case "$a" in
            -a)
                i=$(( $i + 1 ));
                project="${in_args[$i]}";
                if [ ! -d "$project" ]; then
                    echo "Cannot associate project with $project, it is not a directory" 1>&2;
                    return 1;
                fi;
                project="$(virtualenvwrapper_absolutepath ${project})"
            ;;
            -h | --help)
                virtualenvwrapper_mkvirtualenv_help $a;
                return
            ;;
            -i)
                i=$(( $i + 1 ));
                packages="$packages ${in_args[$i]}"
            ;;
            -p | --python*)
                if echo "$a" | grep -q "="; then
                    interpreter="$(echo "$a" | cut -f2 -d=)";
                else
                    i=$(( $i + 1 ));
                    interpreter="${in_args[$i]}";
                fi
            ;;
            -r)
                i=$(( $i + 1 ));
                requirements="${in_args[$i]}";
                requirements="$(virtualenvwrapper_expandpath "$requirements")"
            ;;
            *)
                if [ ${#out_args} -gt 0 ]; then
                    out_args=("${out_args[@]-}" "$a");
                else
                    out_args=("$a");
                fi
            ;;
        esac;
        i=$(( $i + 1 ));
    done;
    if [ ! -z $interpreter ]; then
        out_args=("--python=$interpreter" ${out_args[@]});
    fi;
    set -- "${out_args[@]}";
    eval "envname=\$$#";
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_virtualenv || return 1;
    ( [ -n "$ZSH_VERSION" ] && setopt SH_WORD_SPLIT;
    virtualenvwrapper_cd "$WORKON_HOME" && "$VIRTUALENVWRAPPER_VIRTUALENV" $VIRTUALENVWRAPPER_VIRTUALENV_ARGS "$@" && [ -d "$WORKON_HOME/$envname" ] && virtualenvwrapper_run_hook "pre_mkvirtualenv" "$envname" );
    typeset RC=$?;
    [ $RC -ne 0 ] && return $RC;
    [ ! -d "$WORKON_HOME/$envname" ] && return 0;
    if [ ! -z "$project" ]; then
        setvirtualenvproject "$WORKON_HOME/$envname" "$project";
        RC=$?;
        [ $RC -ne 0 ] && return $RC;
    fi;
    workon "$envname";
    if [ ! -z "$requirements" ]; then
        pip install -r "$requirements";
    fi;
    for a in $packages;
    do
        pip install $a;
    done;
    virtualenvwrapper_run_hook "post_mkvirtualenv"
}
rmvirtualenv ()
{
    virtualenvwrapper_verify_workon_home || return 1;
    if [ ${#@} = 0 ]; then
        echo "Please specify an enviroment." 1>&2;
        return 1;
    fi;
    typeset env_name;
    for env_name in "$@";
    do
        echo "Removing $env_name...";
        typeset env_dir="$WORKON_HOME/$env_name";
        if [ "$VIRTUAL_ENV" = "$env_dir" ]; then
            echo "ERROR: You cannot remove the active environment ('$env_name')." 1>&2;
            echo "Either switch to another environment, or run 'deactivate'." 1>&2;
            return 1;
        fi;
        if [ ! -d "$env_dir" ]; then
            echo "Did not find environment $env_dir to remove." 1>&2;
        fi;
        typeset prior_dir="$(pwd)";
        virtualenvwrapper_cd "$WORKON_HOME";
        virtualenvwrapper_run_hook "pre_rmvirtualenv" "$env_name";
        command \rm -rf "$env_dir";
        virtualenvwrapper_run_hook "post_rmvirtualenv" "$env_name";
        if [ -d "$prior_dir" ]; then
            virtualenvwrapper_cd "$prior_dir";
        fi;
    done
}
setvirtualenvproject ()
{
    typeset venv="$1";
    typeset prj="$2";
    if [ -z "$venv" ]; then
        venv="$VIRTUAL_ENV";
    fi;
    if [ -z "$prj" ]; then
        prj="$(pwd)";
    else
        prj=$(virtualenvwrapper_absolutepath "${prj}");
    fi;
    if [ ! -d "$venv" ]; then
        venv="$WORKON_HOME/$venv";
    fi;
    if [ ! -d "$venv" ]; then
        echo "No virtualenv $(basename $venv)" 1>&2;
        return 1;
    fi;
    if [ ! -d "$prj" ]; then
        echo "Cannot associate virtualenv with \"$prj\", it is not a directory" 1>&2;
        return 1;
    fi;
    echo "Setting project for $(basename $venv) to $prj";
    echo "$prj" > "$venv/$VIRTUALENVWRAPPER_PROJECT_FILENAME"
}
showvirtualenv ()
{
    typeset env_name="$1";
    if [ -z "$env_name" ]; then
        if [ -z "$VIRTUAL_ENV" ]; then
            echo "showvirtualenv [env]";
            return 1;
        fi;
        env_name=$(basename "$VIRTUAL_ENV");
    fi;
    virtualenvwrapper_run_hook "get_env_details" "$env_name";
    echo
}
toggleglobalsitepackages ()
{
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    typeset no_global_site_packages_file="`virtualenvwrapper_get_site_packages_dir`/../no-global-site-packages.txt";
    if [ -f $no_global_site_packages_file ]; then
        rm $no_global_site_packages_file;
        [ "$1" = "-q" ] || echo "Enabled global site-packages";
    else
        touch $no_global_site_packages_file;
        [ "$1" = "-q" ] || echo "Disabled global site-packages";
    fi
}
virtualenvwrapper ()
{
    cat  <<EOF

virtualenvwrapper is a set of extensions to Ian Bicking's virtualenv
tool.  The extensions include wrappers for creating and deleting
virtual environments and otherwise managing your development workflow,
making it easier to work on more than one project at a time without
introducing conflicts in their dependencies.

For more information please refer to the documentation:

    http://virtualenvwrapper.readthedocs.org/en/latest/command_ref.html

Commands available:

EOF

    typeset helpmarker="#:help:";
    cat "$VIRTUALENVWRAPPER_SCRIPT" | grep "^$helpmarker" | sed -e "s/^$helpmarker/  /g" | sort | sed -e 's/$/\''
/g'
}
virtualenvwrapper_absolutepath ()
{
    if [ "$1" = "" ]; then
        return 1;
    else
        "$VIRTUALENVWRAPPER_PYTHON" -c "import os,sys; sys.stdout.write(os.path.abspath(\"$1\")+'\n')";
        return 0;
    fi
}
virtualenvwrapper_cd ()
{
    if [ -n "$BASH" ]; then
        builtin \cd "$@";
    else
        if [ -n "$ZSH_VERSION" ]; then
            builtin \cd -q "$@";
        else
            command \cd "$@";
        fi;
    fi
}
virtualenvwrapper_derive_workon_home ()
{
    typeset workon_home_dir="$WORKON_HOME";
    if [ "$workon_home_dir" = "" ]; then
        workon_home_dir="$HOME/.virtualenvs";
    fi;
    if echo "$workon_home_dir" | ( unset GREP_OPTIONS;
    command \grep '^[^/~]' > /dev/null ); then
        workon_home_dir="$HOME/$WORKON_HOME";
    fi;
    if echo "$workon_home_dir" | ( unset GREP_OPTIONS;
    command \egrep '([\$~]|//)' > /dev/null ); then
        workon_home_dir="$(virtualenvwrapper_expandpath "$workon_home_dir")";
    fi;
    echo "$workon_home_dir";
    return 0
}
virtualenvwrapper_expandpath ()
{
    if [ "$1" = "" ]; then
        return 1;
    else
        "$VIRTUALENVWRAPPER_PYTHON" -c "import os,sys; sys.stdout.write(os.path.normpath(os.path.expanduser(os.path.expandvars(\"$1\")))+'\n')";
        return 0;
    fi
}
virtualenvwrapper_get_python_version ()
{
    "$VIRTUAL_ENV/$VIRTUALENVWRAPPER_ENV_BIN_DIR/python" -V 2>&1 | cut -f2 -d' ' | cut -f-2 -d.
}
virtualenvwrapper_get_site_packages_dir ()
{
    "$VIRTUAL_ENV/$VIRTUALENVWRAPPER_ENV_BIN_DIR/python" -c "import distutils; print(distutils.sysconfig.get_python_lib())"
}
virtualenvwrapper_initialize ()
{
    export WORKON_HOME="$(virtualenvwrapper_derive_workon_home)";
    virtualenvwrapper_verify_workon_home -q || return 1;
    if [ "$VIRTUALENVWRAPPER_HOOK_DIR" = "" ]; then
        export VIRTUALENVWRAPPER_HOOK_DIR="$WORKON_HOME";
    fi;
    mkdir -p "$VIRTUALENVWRAPPER_HOOK_DIR";
    virtualenvwrapper_run_hook "initialize";
    virtualenvwrapper_setup_tab_completion;
    return 0
}
virtualenvwrapper_mkproject_help ()
{
    echo "Usage: mkproject [-f|--force] [-t template] [virtualenv options] project_name";
    echo;
    echo "-f, --force    Create the virtualenv even if the project directory";
    echo "               already exists";
    echo;
    echo "Multiple templates may be selected.  They are applied in the order";
    echo "specified on the command line.";
    echo;
    echo "mkvirtualenv help:";
    echo;
    mkvirtualenv -h;
    echo;
    echo "Available project templates:";
    echo;
    "$VIRTUALENVWRAPPER_PYTHON" -c 'from virtualenvwrapper.hook_loader import main; main()' -l project.template
}
virtualenvwrapper_mktemp ()
{
    command \mktemp "$@"
}
virtualenvwrapper_mkvirtualenv_help ()
{
    echo "Usage: mkvirtualenv [-a project_path] [-i package] [-r requirements_file] [virtualenv options] env_name";
    echo;
    echo " -a project_path";
    echo;
    echo "    Provide a full path to a project directory to associate with";
    echo "    the new environment.";
    echo;
    echo " -i package";
    echo;
    echo "    Install a package after the environment is created.";
    echo "    This option may be repeated.";
    echo;
    echo " -r requirements_file";
    echo;
    echo "    Provide a pip requirements file to install a base set of packages";
    echo "    into the new environment.";
    echo;
    echo 'virtualenv help:';
    echo;
    "$VIRTUALENVWRAPPER_VIRTUALENV" $@
}
virtualenvwrapper_run_hook ()
{
    typeset hook_script;
    typeset result;
    hook_script="$(virtualenvwrapper_tempfile ${1}-hook)" || return 1;
    ( virtualenvwrapper_cd "$WORKON_HOME" && "$VIRTUALENVWRAPPER_PYTHON" -m 'virtualenvwrapper.hook_loader' $HOOK_VERBOSE_OPTION --script "$hook_script" "$@" );
    result=$?;
    if [ $result -eq 0 ]; then
        if [ ! -f "$hook_script" ]; then
            echo "ERROR: virtualenvwrapper_run_hook could not find temporary file $hook_script" 1>&2;
            command \rm -f "$hook_script";
            return 2;
        fi;
        source "$hook_script";
    else
        if [ "${1}" = "initialize" ]; then
            cat - 1>&2  <<EOF
virtualenvwrapper.sh: There was a problem running the initialization hooks.

If Python could not import the module virtualenvwrapper.hook_loader,
check that virtualenvwrapper has been installed for
VIRTUALENVWRAPPER_PYTHON=$VIRTUALENVWRAPPER_PYTHON and that PATH is
set properly.
EOF

        fi;
    fi
    command \rm -f "$hook_script";
    return $result
}
virtualenvwrapper_setup_tab_completion ()
{
    if [ -n "$BASH" ]; then
        function _virtualenvs ()
        {
            local cur="${COMP_WORDS[COMP_CWORD]}";
            COMPREPLY=($(compgen -W "`virtualenvwrapper_show_workon_options`" -- ${cur}))
        };
        function _cdvirtualenv_complete ()
        {
            local cur="$2";
            COMPREPLY=($(cdvirtualenv && compgen -d -- "${cur}" ))
        };
        function _cdsitepackages_complete ()
        {
            local cur="$2";
            COMPREPLY=($(cdsitepackages && compgen -d -- "${cur}" ))
        };
        complete -o nospace -F _cdvirtualenv_complete -S/ cdvirtualenv;
        complete -o nospace -F _cdsitepackages_complete -S/ cdsitepackages;
        complete -o default -o nospace -F _virtualenvs workon;
        complete -o default -o nospace -F _virtualenvs rmvirtualenv;
        complete -o default -o nospace -F _virtualenvs cpvirtualenv;
        complete -o default -o nospace -F _virtualenvs showvirtualenv;
    else
        if [ -n "$ZSH_VERSION" ]; then
            function _virtualenvs ()
            {
                reply=($(virtualenvwrapper_show_workon_options))
            };
            function _cdvirtualenv_complete ()
            {
                reply=($(cdvirtualenv && ls -d ${1}*))
            };
            function _cdsitepackages_complete ()
            {
                reply=($(cdsitepackages && ls -d ${1}*))
            };
            compctl -K _virtualenvs workon rmvirtualenv cpvirtualenv showvirtualenv;
            compctl -K _cdvirtualenv_complete cdvirtualenv;
            compctl -K _cdsitepackages_complete cdsitepackages;
        fi;
    fi
}
virtualenvwrapper_show_workon_options ()
{
    virtualenvwrapper_verify_workon_home || return 1;
    ( virtualenvwrapper_cd "$WORKON_HOME" && echo */$VIRTUALENVWRAPPER_ENV_BIN_DIR/activate ) 2> /dev/null | command \tr "\n" " " | command \sed "s|/$VIRTUALENVWRAPPER_ENV_BIN_DIR/activate |/|g" | command \tr "/" "\n" | command \sed "/^\s*$/d" | ( unset GREP_OPTIONS;
    command \egrep -v '^\*$' ) 2> /dev/null
}
virtualenvwrapper_tempfile ()
{
    typeset suffix=${1:-hook};
    typeset file;
    file="$(virtualenvwrapper_mktemp -t virtualenvwrapper-$suffix-XXXXXXXXXX)";
    touch "$file";
    if [ $? -ne 0 ] || [ -z "$file" ] || [ ! -f "$file" ]; then
        echo "ERROR: virtualenvwrapper could not create a temporary file name." 1>&2;
        return 1;
    fi;
    echo $file;
    return 0
}
virtualenvwrapper_verify_active_environment ()
{
    if [ ! -n "${VIRTUAL_ENV}" ] || [ ! -d "${VIRTUAL_ENV}" ]; then
        echo "ERROR: no virtualenv active, or active virtualenv is missing" 1>&2;
        return 1;
    fi;
    return 0
}
virtualenvwrapper_verify_project_home ()
{
    if [ -z "$PROJECT_HOME" ]; then
        echo "ERROR: Set the PROJECT_HOME shell variable to the name of the directory where projects should be created." 1>&2;
        return 1;
    fi;
    if [ ! -d "$PROJECT_HOME" ]; then
        [ "$1" != "-q" ] && echo "ERROR: Project directory '$PROJECT_HOME' does not exist.  Create it or set PROJECT_HOME to an existing directory." 1>&2;
        return 1;
    fi;
    return 0
}
virtualenvwrapper_verify_resource ()
{
    typeset exe_path="$(command \which "$1" | (unset GREP_OPTIONS; command \grep -v "not found"))";
    if [ "$exe_path" = "" ]; then
        echo "ERROR: virtualenvwrapper could not find $1 in your path" 1>&2;
        return 1;
    fi;
    if [ ! -e "$exe_path" ]; then
        echo "ERROR: Found $1 in path as \"$exe_path\" but that does not exist" 1>&2;
        return 1;
    fi;
    return 0
}
virtualenvwrapper_verify_virtualenv ()
{
    virtualenvwrapper_verify_resource $VIRTUALENVWRAPPER_VIRTUALENV
}
virtualenvwrapper_verify_virtualenv_clone ()
{
    virtualenvwrapper_verify_resource $VIRTUALENVWRAPPER_VIRTUALENV_CLONE
}
virtualenvwrapper_verify_workon_environment ()
{
    typeset env_name="$1";
    if [ ! -d "$WORKON_HOME/$env_name" ]; then
        echo "ERROR: Environment '$env_name' does not exist. Create it with 'mkvirtualenv $env_name'." 1>&2;
        return 1;
    fi;
    return 0
}
virtualenvwrapper_verify_workon_home ()
{
    RC=0;
    if [ ! -d "$WORKON_HOME/" ]; then
        if [ "$1" != "-q" ]; then
            echo "NOTE: Virtual environments directory $WORKON_HOME does not exist. Creating..." 1>&2;
        fi;
        mkdir -p "$WORKON_HOME";
        RC=$?;
    fi;
    return $RC
}
virtualenvwrapper_workon_help ()
{
    echo "Usage: workon env_name";
    echo "";
    echo "           Deactivate any currently activated virtualenv";
    echo "           and activate the named environment, triggering";
    echo "           any hooks in the process.";
    echo "";
    echo "       workon";
    echo "";
    echo "           Print a list of available environments.";
    echo "           (See also lsvirtualenv -b)";
    echo "";
    echo "       workon (-h|--help)";
    echo "";
    echo "           Show this help message.";
    echo "";
    echo "       workon (-c|--cd) envname";
    echo "";
    echo "           After activating the environment, cd to the associated";
    echo "           project directory if it is set.";
    echo "";
    echo "       workon (-n|--no-cd) envname";
    echo "";
    echo "           After activating the environment, do not cd to the";
    echo "           associated project directory.";
    echo ""
}
wipeenv ()
{
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    typeset req_file="$(virtualenvwrapper_tempfile "requirements.txt")";
    pip freeze | egrep -v '(distribute|wsgiref)' > "$req_file";
    if [ -n "$(cat "$req_file")" ]; then
        echo "Uninstalling packages:";
        cat "$req_file";
        echo;
        pip uninstall -y $(cat "$req_file" | grep -v '^-f' | sed 's/>/=/g' | cut -f1 -d=);
    else
        echo "Nothing to remove.";
    fi;
    rm -f "$req_file"
}
workon ()
{
    typeset -a in_args;
    typeset -a out_args;
    in_args=("$@");
    if [ -n "$ZSH_VERSION" ]; then
        i=1;
        tst="-le";
    else
        i=0;
        tst="-lt";
    fi;
    typeset cd_after_activate=$VIRTUALENVWRAPPER_WORKON_CD;
    while [ $i $tst $# ]; do
        a="${in_args[$i]}";
        case "$a" in
            -h | --help)
                virtualenvwrapper_workon_help;
                return 0
            ;;
            -n | --no-cd)
                cd_after_activate=0
            ;;
            -c | --cd)
                cd_after_activate=1
            ;;
            *)
                if [ ${#out_args} -gt 0 ]; then
                    out_args=("${out_args[@]-}" "$a");
                else
                    out_args=("$a");
                fi
            ;;
        esac;
        i=$(( $i + 1 ));
    done;
    set -- "${out_args[@]}";
    typeset env_name="$1";
    if [ "$env_name" = "" ]; then
        lsvirtualenv -b;
        return 1;
    else
        if [ "$env_name" = "." ]; then
            IFS='%';
            env_name="$(basename $(pwd))";
            unset IFS;
        fi;
    fi;
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_workon_environment "$env_name" || return 1;
    activate="$WORKON_HOME/$env_name/$VIRTUALENVWRAPPER_ENV_BIN_DIR/activate";
    if [ ! -f "$activate" ]; then
        echo "ERROR: Environment '$WORKON_HOME/$env_name' does not contain an activate script." 1>&2;
        return 1;
    fi;
    type deactivate > /dev/null 2>&1;
    if [ $? -eq 0 ]; then
        deactivate;
        unset -f deactivate > /dev/null 2>&1;
    fi;
    virtualenvwrapper_run_hook "pre_activate" "$env_name";
    source "$activate";
    virtualenvwrapper_original_deactivate=`typeset -f deactivate | sed 's/deactivate/virtualenv_deactivate/g'`;
    eval "$virtualenvwrapper_original_deactivate";
    unset -f deactivate > /dev/null 2>&1;
    eval 'deactivate () {
        typeset env_postdeactivate_hook
        typeset old_env

        # Call the local hook before the global so we can undo
        # any settings made by the local postactivate first.
        virtualenvwrapper_run_hook "pre_deactivate"

        env_postdeactivate_hook="$VIRTUAL_ENV/$VIRTUALENVWRAPPER_ENV_BIN_DIR/postdeactivate"
        old_env=$(basename "$VIRTUAL_ENV")

        # Call the original function.
        virtualenv_deactivate $1

        virtualenvwrapper_run_hook "post_deactivate" "$old_env"

        if [ ! "$1" = "nondestructive" ]
        then
            # Remove this function
            unset -f virtualenv_deactivate >/dev/null 2>&1
            unset -f deactivate >/dev/null 2>&1
        fi

    }';
    VIRTUALENVWRAPPER_PROJECT_CD=$cd_after_activate virtualenvwrapper_run_hook "post_activate";
    return 0
}

